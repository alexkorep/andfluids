#include <android_native_app_glue.h>
#include <android/native_window.h>
#include <android/input.h>
#include <android/looper.h>

#include <errno.h>
#include <jni.h>
#include <android/log.h>

#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#define  LOG_TAG    "andfluids"
#define  LOGI(...)  __android_log_print(ANDROID_LOG_INFO,LOG_TAG,__VA_ARGS__)
#define  LOGW(...)  __android_log_print(ANDROID_LOG_WARN,LOG_TAG,__VA_ARGS__)
#define  LOGE(...)  __android_log_print(ANDROID_LOG_ERROR,LOG_TAG,__VA_ARGS__)

/**
 * @param buffer i/o - native window buffer structure, will be updated in order to draw the frame
 */
static void draw_frame(ANativeWindow_Buffer& buffer)
{
    void* pixels = buffer.bits;
    //LOGI("width=%d height=%d stride=%d format=%d", buffer->width, buffer->height,
    //        buffer->stride, buffer->format);

    for (int yy = 0; yy < buffer.height; ++yy) {
        uint16_t*  line = (uint16_t*)pixels;

        for (int xx = 0; xx < buffer.width; ++xx) {
            line[xx] = 255%xx;
        }

    }

}

static void engine_draw_frame(android_app* app) {
    if (app->window == NULL) {
        // No window.
        return;
    }

    ANativeWindow_Buffer buffer;
    if (ANativeWindow_lock(app->window, &buffer, NULL) < 0) {
        LOGW("Unable to lock window buffer");
        return;
    }

    draw_frame(buffer);

    ANativeWindow_unlockAndPost(app->window);
}

/*
static int engine_term_display(struct engine* engine) {
    engine->animating = 0;
}
*/

static int32_t engine_handle_input(struct android_app* app, AInputEvent* event) {
    //struct engine* engine = (struct engine*)app->userData;
    if (AInputEvent_getType(event) == AINPUT_EVENT_TYPE_MOTION) {
        //engine->animating = 1;
        return 1;
    } else if (AInputEvent_getType(event) == AINPUT_EVENT_TYPE_KEY) {
        LOGI("Key event: action=%d keyCode=%d metaState=0x%x",
                AKeyEvent_getAction(event),
                AKeyEvent_getKeyCode(event),
                AKeyEvent_getMetaState(event));
    }

    return 0;
}

static void engine_handle_cmd(struct android_app* app, int32_t cmd) {
    //struct engine* engine = (struct engine*)app->userData;
    switch (cmd) {
        case APP_CMD_INIT_WINDOW:
            if (app->window != NULL) {
                engine_draw_frame(app);
            }
            break;
        case APP_CMD_TERM_WINDOW:
            //engine_term_display(engine);
            break;
        case APP_CMD_LOST_FOCUS:
            //engine->animating = 0;
            engine_draw_frame(app);
            break;
    }
}

void android_main(struct android_app* state) {
    static int init;

    LOGI("App started.");

    // Make sure glue isn't stripped.
    app_dummy();

    state->userData = 0; // Just in case
    state->onAppCmd = engine_handle_cmd;
    state->onInputEvent = engine_handle_input;


    // loop waiting for stuff to do.

    while (1) {
        // Read all pending events.
        int ident;
        int events;
        struct android_poll_source* source;

        // If not animating, we will block forever waiting for events.
        // If animating, we loop until all events are read, then continue
        // to draw the next frame of animation.
        while ((ident=ALooper_pollAll(0, NULL, &events, (void**)&source)) >= 0) {

            // Process this event.
            if (source != NULL) {
                source->process(state, source);
            }

            // Check if we are exiting.
            if (state->destroyRequested != 0) {
                LOGI("Engine thread destroy requested!");
                //engine_term_display(&engine);
                return;
            }
        }

        engine_draw_frame(state);
    }
}
